def export():
    lib_name = "minai"
    author = "nblzv"
    version = "0.1.0"

    #------------

    import mintils
    mintils.push_timing_scope()

    from pathlib import Path
    import json
    import subprocess
    
    this_file = Path(__file__)
    source_dir = this_file.parent
    print_relative_to = source_dir.parent

    dest_dir = source_dir.parent / lib_name / lib_name; dest_dir.mkdir(exist_ok=True, parents=True)

    for source_file in source_dir.iterdir():
        if source_file.name.startswith("_"): continue
        if source_file == this_file: continue
        assert not source_file.is_dir(), "Directories are currently not supported"

        mintils.push_timing_scope()

        dest_filename = f"{source_file.name[:source_file.name.rindex('.')]}.py"
        dest_file = dest_dir / dest_filename; dest_file.touch()
        print(f"Processing {source_file.name} -> {dest_file.relative_to(print_relative_to)}")

        if source_file.suffix == ".ipynb":
            parsed = {}
            with open(source_file, "rt") as fd:
                parsed = json.load(fd)
            
            code = [f"# Autogenerated! Edit {source_file.relative_to(print_relative_to)} instead\n"]
            exported_count = 0
            for cell in parsed["cells"]:
                if cell["cell_type"] == "code":
                    src = cell["source"]
                    if src and src[0].startswith("#e"):
                        code.append("".join(src[1:]))
                        exported_count += 1
            
            # Allow for 0 cell exports to effectively wipe the previous contents

            dest_file_temp = dest_file.with_suffix(".temp.py")

            code.append("")
            code_joined = "\n".join(code)

            with open(dest_file, "r+t") as fd:
                if mintils.have_same_conents(fd, code_joined):
                    dest_file_temp.unlink(missing_ok=True)
                    print(f"  same contents, skipping, {mintils.pop_and_string_timing_scope()}")

                else:
                    print(f"  validating {exported_count} cells... ", end="", flush=True) # Can take a while to run so flush

                    with open(dest_file_temp, "wt") as tfd:
                        tfd.write(code_joined)
                    
                    res = subprocess.run(["python", dest_file_temp], capture_output=True, text=True)
                    if res.returncode or res.stdout or res.stderr:
                        print(f"failed, exiting, {mintils.pop_and_string_timing_scope()}\nstdout: {bool(res.stdout)}, stderr: {bool(res.stderr)}, returncode: {res.returncode}")
                        print(res.stderr)
                        quit(-1)

                    dest_file_temp.unlink()
                    print(f"exported, {mintils.pop_and_string_timing_scope()}")
                    mintils.overwrite_file(fd, code_joined)
        
        else:
            assert source_file.suffix == ".py"

            code_joined = f"# Autogenerated! Edit {source_file.relative_to(print_relative_to)} instead\n\n"
            with open(source_file, "rt") as fd:
                code_joined += fd.read()

            with open(dest_file, "r+t") as fd:
                if mintils.have_same_conents(fd, code_joined):
                    print(f"  same contents, skipping, {mintils.pop_and_string_timing_scope()}")

                else:
                    print(f"  copied contents, {mintils.pop_and_string_timing_scope()}")
                    mintils.overwrite_file(fd, code_joined)

    # TODO: Template files for setup and init?
    init_file = dest_dir / "__init__.py"; init_file.touch()
    init_file_source = "\n".join(
    [
        f"# Autogenerated! Edit {this_file.relative_to(print_relative_to)} instead",
        "",
        f'__version__ = "{version}"',
        "",
    ])
    with open(init_file, "rt+") as fd:
        if not mintils.have_same_conents(fd, init_file_source):
            mintils.overwrite_file(fd, init_file_source)

    setup_py_file = dest_dir.parent / "setup.py"; setup_py_file.touch()
    setup_py_file_source = "\n".join(
    [
        f"# Autogenerated! Edit {this_file.relative_to(print_relative_to)} instead",
        "",
        "from setuptools import setup, find_packages",
        "",
        f'setup(name="{lib_name}", author="{author}", version="{version}", packages=find_packages())',
        "",
    ])

    with open(setup_py_file, "rt+") as fd:
        if not mintils.have_same_conents(fd, setup_py_file_source):
            mintils.overwrite_file(fd, setup_py_file_source)

    print(f"\nAll done... {mintils.pop_and_string_timing_scope()}")
    print(f"  lib_name: {lib_name}")
    print(f"  author: {author}")
    print(f"  version: {version}")

    if not (dest_dir.parent / f"{lib_name}.egg-info").exists():
        print("\nTo install locally run:")
        print(f"  pip install -e {dest_dir.parent}")

if __name__ == "__main__":
    export()